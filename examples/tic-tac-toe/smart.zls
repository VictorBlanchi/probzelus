open Tictactoe
open Probzelus
open Engine
open Nested_infer
open Infer_pf


let display_size = 100
let board_size = 3

let node utility ((b , p) : board * player) =
    if has_won b p
    then 50.
    else if has_won b (switch_player p)
    then -. 100.
    else 0.

let node move_prior (b : board)  = (m : move Distribution.t) where
  rec m = Distribution.uniform_list (valid_moves b)

let proba expected_utility (b0, p0, m0 : board * player * move) = (u : float) where
     rec init b = b0
     and init u = 0.
     and p = p0 fby switch_player p
     and automaton
    | NotTerminal ->
      do m = m0 -> sample (move_prior (last b))
      and b = transition (last b) m p
      and u = last u -. 5.
      until (is_terminal b) then Terminal
    | Terminal ->
      do u = last u +. (utility (b, p0) fby 0.) done
    end

let proba model ((b, p) : board * player) = (m : move) where
    rec m = sample (move_prior b)
    and eu = expected_utility (b, p, m)
    and () = factor eu

let node main () = () where
  rec
  automaton
  | ME ->
    do
      move = interactive_player display_size (last board)
      and player = Cross
    then AI
  | AI ->
    do
      reset move = plan 10 100 model ((last board), player)
	every true
      and player = Circle
    then ME
  end
  and
  init board = (Tictactoe.restart display_size board_size)
  and board = (Tictactoe.play_one display_size (last board) player move)

(* let proba simulate ((b0, p0, m0) : board * player * move) =
    (u: float) where
    rec p = (switch_player p0) fby switch_player p
    and init b = b0
    and init m = m0
    and nat = from 0
    and automaton
    | NotTerminal ->
      do m = Distribution.draw (nested_infer_alice (last b , p))
      and b = transition (last b) m p
      and () = print_bool (is_terminal b)
      and () = print_board b
      and u = 0.
      unless (is_terminal b0) then Terminal
    | Terminal ->
      do u = utility (b, p0) 
      and () = print_string "Terminal"; print_newline () done
    end

let proba simulate' ((b0, p0, m0) : board * player * move) = (u : float)
    where
    rec reset u = if is_terminal b0 then utility(b, p0) else simulate (b0, p0, m0) every true

let proba model ((b, p) : board * player) = (m : move) where
  rec m = Infer_pf.sample (move_prior b)
  and new_b = transition b m p
  and eu = Distribution.mean_float (nested_infer_bob (b, p, m))
  and () = Infer_pf.factor eu

let node main () = () where
  rec
  automaton
  | ME ->
    do
      move = interactive_player display_size (last board)
      and player = Cross
    then AI
  | AI ->
    do
      reset move = Distribution.draw
        ( do_infer_alice
	  model
	  simulate'
	  (last board , player))
	every true
      and player = Circle
    then ME
  end
  and
  init board = (Tictactoe.restart display_size board_size)
  and board = (Tictactoe.play_one display_size (last board) player move)

 *)